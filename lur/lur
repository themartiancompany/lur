#!/usr/bin/env bash
#
# SPDX-License-Identifier: AGPL-3.0

_bin="$( \
  dirname \
    "$( \
      command \
        -v \
	  "env")")"
_lib="${_bin}/../lib"
_share="${_bin}/../share"
source \
  "${_lib}/libcrash-bash/crash-bash"

# Check all required programs
# are available
_requirements() {
  _check_cmd \
    'git'
  _check_cmd \
    'rsync'
}

# shellcheck disable=SC2034
_global_variables() {
  packaging_date=""
  local_packages=()
  repo_dir=""
  source_origin=""
  source_publisher=""
  no_build=""
  build_mode=""
  work_dir=""
  output_dir=""
  color=""
  quiet=""
}

_source_retrieve() {
  local \
    _pkgname="${1}" \
    _source="${2}" \
    _publisher="${3}" \
    _repo="${4}" \
    _aspe_opts=()
  if [[ "${quiet}" == "n" ]]; then
    _aspe_opts+=(
      -v
    )
  fi
  _aspe_opts+=(
    -S
      "${_source}"
    -o
      "${_repo}"
  )
  aspe \
    "${_aspe_opts[@]}" \
    "${_pkgname}"
}

_makepkg() {
  local \
    _pkgname="${1}" \
    _repo="${2}" \
    _source="${3}" \
    _publisher="${4}" \
    _work_dir="${5}" \
    _reallymakepkg_opts=() \
    _key \
    _gpg_keys \
    _oldpwd \
    _pkg_files=()
    # _awk_pgpkeys_cmd='/validpgpkeys=/{flag=1;next}/\)/{flag=0}flag' \
  _oldpwd="$( \
    pwd)"
  if [[ "${quiet}" == "n" ]]; then
    _reallymakepkg_opts+=(
      -v
    )
  fi
  if [[ "${_work_dir}" != "" ]]; then
    _reallymakepkg_opts+=(
      -w
        "${work_dir}"
    )
  fi
  if [[ ! -d "${_repo}" ]]; then
    _msg_info \
      "lur repo '${_repo}' not found, creating"
    mkdir \
      -p \
      "${_repo}"
  fi
  if [[ ! -d "${_repo}/${_pkgname}" ]]; then
    _msg_info \
      "package '${_pkgname}' not found, retrieving"
    _source_retrieve \
      "${_pkgname}" \
      "${_source}" \
      "${_repo}"
  elif [[ ! -e "${_repo}/${_pkgname}/PKGBUILD" ]]; then
    _msg=(
      "directory not empty but PKGBUILD missing;"
      "check source"
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
  cd \
    "${_repo}/${_pkgname}"
  _gpg_keys=( $( \
    recipe-get \
      "${_repo}/${_pkgname}/PKGBUILD" \
      "validpgpkeys")
  )
  for _key \
    in "${_gpg_keys[@]}"; do
    gpg \
      --recv-keys \
      "${validpgpkeys[@]}"
  done
  reallymakepkg \
    "${_reallymakepkg_opts[@]}" -- \
    -df \
    --nocheck
  _msg_info \
    "current directory: $(pwd)"
  ls \
    .
  _pkg_files=( $( \
    ls \
      ./*".pkg.tar."*)
  )
  _msg_info \
    "clean work dir ${_work_dir}"
  # rm \
  #   -rf \
  #   "${_work_dir}"
  _msg_info \
    "moving packages '${_pkg_files[*]}' to '${_server}'"
  mv \
    "${_pkg_files[*]}" \
    "${_server}"
}

_build_pkg() {
  local \
    _pkgname="${1}" \
    _mode="${2}"  \
    _origin="${3}" \
    _publisher="${4}" \
    _repo="${5}" \
    _server="${6}" \
    _work_dir="${7}" \
    _pwd
  _oldpwd="$( \
    pwd)"
  echo \
    "building ${_pkgname}"
  if [ "${_mode}" = "src" ]; then
    _makepkg \
      "${_pkgname}" \
      "${_repo}" \
      "${_origin}" \
      "${_publisher}" \
      "${_work_dir}/${_pkgname}"
  elif [ "${_mode}" = "fakepkg" ]; then
    cd \
      "${_server}" || \
      exit
    fakepkg \
      "${_pkgname}"
  fi
  cd \
    "${_server}" || \
    exit
  # repo-add \
  #   "${_profile}.db.tar.gz" \
  #   "${_pkgname}"*".pkg.tar."*
  cd \
    "${_oldpwd}"
}

_server_setup() {
  local \
    _server="${1}" \
    _user \
    _group
  if [[ ! -d "${_server}" ]]; then
    _msg=(
      "server '${_server}' does not exist," \
      "creating"
    )
    _msg_info \
      "${_msg[*]}"
    mkdir \
      -p \
      "${_server}"
  fi
  _user="$( \
    id \
      -un)"
  _group="$( \
    id \
      -gn)"
  _msg_info \
    "set permissions"
  chown \
    "${_user}:${_group}" \
    "${_server}"
  chmod \
    700 \
    "${_server}" 
}

_build_repo() {
  local \
    _mode="${1}" \
    _repo="${2}" \
    _origin="${3}" \
    _server="${4}" \
    _work_dir="${5}" \
    _packages=() \
    _work_dir \
    _oldpwd \
    _pkg
  shift \
    5
  _packages=(
    "$@"
  )
  _oldpwd=$( \
    pwd)
  # shellcheck source=./packages.extra
  # shellcheck disable=SC1091
  # source \
  #   "${_pwd}/${_packages}"
  if [[ "${_server}" == "" ]]; then
    _server="$( \
      mktemp \
        -d)"
  fi
  if [[ "${_work_dir}" == "" ]]; then
    _work_dir="$( \
      mktemp \
        -d)"
  fi
  _server_setup \
    "${_server}"
  # cd \
  #   "${_server}"
  # shellcheck disable=SC2154
  _msg_info \
    "building repo for packages '${_packages[*]}'"
  for _pkg \
    in "${_packages[@]}"; do
    _build_pkg \
      "${_pkg}" \
      "${_mode}" \
      "${_origin}" \
      "${_repo}" \
      "${_server}" \
      "${_work_dir}"
  done
  cd \
    "${_oldpwd}"
}

_pkgs_find() {
  local \
    _dir="${1}" \
    _pkgver="${2}" \
    _pkgname=() \
    _find_opts=() \
    _pkg \
    _pkgname_length
  shift \
    2
  _pkgname=(
    "$@"
  )
  _msg=(
    "looking for packages '${_pkgname[*]}'"
    "with version '${_pkgver}' in '${_dir}'."
  )
  _msg_info \
    "${_msg[*]}"
  _find_opts+=(
    -type
      "f"
    \(
  )
  _pkgname_length="${#_pkgname[@]}"
  for _pkg in "${_pkgname[@]::${_pkgname_length}-1}"; do
    _find_opts+=(
      -iname
        "${_pkg}-${_pkgver}-*.pkg.*"
      -o
    )
  done
  _find_opts+=(
    -iname
      "${_pkgname[-1]}-${_pkgver}-*.pkg.*"
    \)
    -print0
  )
  _msg=(
    "running find with options"
    "'${_find_opts[@]}'"
  )
  _msg_info \
    "${_msg[*]}"
  mapfile \
    -d \
    $'\0' \
    _pkgs < \
    <(find \
        "${_dir}" \
        "${_find_opts[@]}" 2>/dev/null || \
      true)
}

_nobuild() {
  local \
    _pkgbase \
    _pkgname=() \
    _pkgver \
    _msg=() \
    _pkgbuild \
    _pkgs=() \
    _oldpwd \
    _search_dir
  _oldpwd="$( \
    realpath \
      "$(pwd)")"
  _msg=(
    "entering repo '${_repo_dir}'"
  )
  cd \
    "${_repo_dir}"
  for _pkgbase in "${_packages[@]}"; do
    _pkgbuild="${_pkgbase}/PKGBUILD"
    _msg=(
      "option 'no build' selected,"
      "reading packages built for"
      "'${_pkgbase}' in PKGBUILD"
      "'${_pkgbuild}'."
    )
    _msg_info \
      "${_msg[*]}"
    if [[ ! -e "${_pkgbuild}" ]]; then
      _msg=(
        "PKGBUILD '${_pkgbuild}'"
	"does not exist."
      )
      _msg_error \
        "${_msg[*]}" \
	1
    fi
    _pkgname=( $( \
      recipe-get \
        "${_pkgbuild}" \
        "pkgname")
    )
    _pkgver="$( \
      recipe-get \
        "${_pkgbuild}" \
        "pkgver")"
    if [[ "${_pkgname[*]}" == "" ]]; then
      _msg=(
        "no packages declared in '${_pkgbuild}'."
      )
      _msg_error \
        "${_msg[*]}" \
	1
    fi
    _search_dir="$( \
      realpath \
        "${_repo_dir}")"
    _pkgs_find \
      "${_search_dir}" \
      "${_pkgver}" \
      "${_pkgname[@]}"
    if [[ "${_pkgs[*]}" != "" ]]; then
      _msg_info \
        "option 'no build' selected: found packages '${_pkgs[*]}'"
      _msg_info \
        "copying packages to ${_output_dir}"
      rsync \
        "${_pkgs[@]}" \
        "${_output_dir}"
    elif [[ "${_pkgs[*]}" == "" ]]; then
      _msg_info \
        "not found ${_pkg} packages in lur repo '${_repo_dir}'"
      _msg_info \
        "packaging ${_pkg}"
      _build_repo \
        "${_build_mode}" \
        "${_repo_dir}" \
        "${_origin}" \
        "${_output_dir}" \
        "${_work_dir}" \
        "${_pkg}"
    fi
  done
  _msg=(
    "returning to '${_oldpwd}'"
  )
  cd \
    "${_oldpwd}"
}

# $@: packages
_lur() {
  local \
    _output_dir="${1}" \
    _repo_dir="${2}" \
    _origin="${3}" \
    _no_build="${4}" \
    _build_mode="${5}" \
    _work_dir="${6}" \
    _packages=() \
    _pkgs=() \
    _pacman_opts=() \
    _aspe_opts=() \
    _opts=() \
    _msg=() \
    _pkg
  shift \
    6
  _packages=(
    "$@"
  )
  if [[ "${_no_build}" == "true" ]]; then
    _nobuild
  elif [[ "${_no_build}" == "false" ]]; then
    _build_repo \
      "${_build_mode}" \
      "${_repo_dir}" \
      "${_origin}" \
      "${_output_dir}" \
      "${_work_dir}" \
      "${_packages[@]}"
  fi
}

# Set defaults and, if present, overrides
# from arch-grub command line option parameters
_set_overrides() {
  local \
    _msg=() \
    _date
  _set_override \
    "packaging" \
    "date" \
    "$(_get_date_human)"
  _date="$( \
    echo \
      "$(_get \
        "packaging" \
	"date")" | \
      sed \
        "s/://g")"
  _set_override \
    "repo" \
    "dir" \
    "${HOME}/lur"
  _set_override \
    "work" \
    "dir" \
    "${HOME}/.cache/lur/build-${_date}"
  _set_override \
    "source" \
    "origin" \
    "ur"
  _set_override \
    "no" \
    "build" \
    "false"
  _set_override \
    "build" \
    "mode" \
    "src"
   _set_override \
    "output" \
    "dir" \
    "$(pwd)"
if [[ -v override_color ]]; then
    color="${override_color}"
  elif [[ -z "${color}" ]]; then
    color="n"
  fi
  if [[ -v override_quiet ]]; then
    quiet="${override_quiet}"
  elif [[ -z "${quiet}" ]]; then
    quiet="y"
  fi
  if [[ "${local_packages[*]}" == "" ]]; then
    local_packages+=(
      "$(basename \
        "$(realpath \
          "$(pwd)")")"
    )
    _msg=(
      "No input package given,"
      "publishing ${local_packages[*]}"
    )
    _msg_info \
      "${_msg[*]}"
  fi
}

# Show help usage, with an exit status.
# $1: exit status number.
_usage() {
  local \
    _exit="${1}" \
    _usage_text
  IFS='' \
    read \
      -r \
      -d '' \
      _usage_text << \
        ENDUSAGETEXT || true

Usage:
  $(_get "app" "name")
    [options]
    [packages]
  options:
     -d <repo_dir>        Repo directory.
			  Default: $(_get "repo" "dir")
     -b <build_mode>      Values are 'src' or 'fakepkg'
			  Default: $(_get "build" "mode")
     -S <origin>          Repo origin.
			  Default: $(_get "repo" "origin")
     -o <output_dir>      Output directory.
			  Default: $(_get "output" "dir")
     -n                   No build.
			  Default: $(_get "no" "build")
     -c                   Colors.
     -h                   This message.
     -v                   Enable verbose output
ENDUSAGETEXT
  _printf \
    '%s\n' \
    "${_usage_text}"
  exit \
    "${_exit}"
}

# Shows configuration options.
_show_config() {
  _msg_info "${app_name} configuration"
  _msg_info "           Packaging date:   $(_get "packaging" "date")"
  _msg_info "            Source origin:   $(_get "source" "origin")"
  _msg_info "           Repo directory:   $(_get "repo" "dir")"
  _msg_info "           Work directory:   $(_get "work" "dir")"
  _msg_info "                 No build:   $(_get "no" "build")"
  _msg_info "               Build mode:   $(_get "build" "mode")"
  _msg_info "         Output directory:   $(_get "output" "dir")"
  _msg_info "                 Packages:   ${local_packages}"
}

_globals
_global_variables
_requirements
# shellcheck disable=SC2004
# shellcheck disable=SC2034
while \
  getopts \
    'd:b:S:o:w:ncvh?' \
    arg; do
  case \
    "${arg}" in
    d) override_repo_dir="${OPTARG}" ;;
    b) override_build_mode="${OPTARG}" ;;
    S) override_source_origin="${OPTARG}" ;;
    o) override_output_dir="${OPTARG}" ;;
    w) override_work_dir="${OPTARG}" ;;
    n) override_no_build="true" ;;
    c) override_color="y" ;;
    v) override_quiet="n" ;;
    h|?) _set_overrides && \
	 _usage \
           0 ;;
    *)
    _msg_error \
      "Invalid argument '${arg}'" \
      0 && \
    _set_overrides && \
    _usage \
      1
    ;;
  esac
done
shift \
  $(( \
    OPTIND - 1 \
  ))
local_packages+=(
  $@
)
_config_user_init \
  "$(_get \
    "app" \
    "name")"
_set_overrides
_show_config
app_opts=(
  "${output_dir}"
  "${repo_dir}"
  "${source_origin}"
  "${no_build}"
  "${build_mode}"
  "${work_dir}"
  "${local_packages[@]}"
)
_lur \
  "${app_opts[@]}"

